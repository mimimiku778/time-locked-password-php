<?php

declare(strict_types=1);

/**
 * Encrypt and decrypt strings using AES-CBC and obtain hashes of encrypted strings using HKDF.
 * 
 * @author mimimiku778 <0203.sub@gmail.com>
 * @license https://github.com/mimimiku778/MimimalCMS/blob/master/LICENSE.md
 */
class StringCryptor
{
    public string $hkdfKey;
    public string $opensslKey;

    /**
     * Set a protected key. If this method is not used, the key set in `MimimalCmsConfig` will be used.
     * 
     * **Example of key generation**
     * 
     * * Generate a key from an arbitrary password
     * `$key = hash('sha256', 'YOUR_PASSWORD');`
     * 
     * * Generate a random key
     * `$key = bin2hex(random_bytes(32));`
     * 
     * @param string $hkdfKey    The HKDF key to use. If null, the default key will be used.
     * @param string $opensslKey The OpenSSL key to use. If null, the default key will be used.
     */
    public function __construct(string $hkdfKey, string $opensslKey)
    {
        $this->hkdfKey = $hkdfKey;
        $this->opensslKey = $opensslKey;
    }

    /**
     * Encrypts a string to a Base64 URL encoded string using AES-CBC and obtains the hash of the encrypted string using HKDF.
     * 
     * @param string $string The string to be encrypted and hashed.
     *               * *Example:* `'Hello World'`
     * @param string|null $additionalHashData Additional data to include in hash calculation but not in encryption.
     *               * *Example:* `'2024-12-25T10:00:00Z'`
     * 
     * @return string Returns a Base64 URL encoded string containing encrypted text and its hash, 
     *                decryptable using `verifyHashAndDecrypt()` method only.
     *  * *Example:* 
     *  `'cnJHV0JVR2dRSFRyeE9JU0VzQVRndz09QE1LMGG4VjBzV25yeXhBd1MzVmR0RFE9PSNMd1YwMHVWc3FQVHNXWnZUSG0raXU4VnJhWld1NGFCZ3R2ZmtWUT09QFIxMk9yK0FVSEJZajJ5NDdzRE5CZlE9PQ'`
     * 
     * @throws \LogicException If the encryption fails.
     */
    public function encryptAndHashString(string $string, ?string $additionalHashData = null): string
    {
        $encryptedString = $this->encryptAesCbcString($string);
        $hashInput = $encryptedString . ($additionalHashData ?? '');
        $hash = $this->hashHkdf($hashInput);

        return $this->encodeBase64URL($encryptedString . '#' . $hash);
    }

    /**
     * Verifies the hash of a Base64 URL encoded encrypted string and returns the decrypted string.
     * 
     * @param string $encryptedString A Base64 URL encoded string that is a concatenation of the encrypted string and its hash, 
     *                                generated by `encryptAndHashString()` method only.
     * * *Example:*
     *  `'cnJHV0JVR2dRSFRyeE9JU0VzQVRndz09QE1LMGG4VjBzV25yeXhBd1MzVmR0RFE9PSNMd1YwMHVWc3FQVHNXWnZUSG0raXU4VnJhWld1NGFCZ3R2ZmtWUT09QFIxMk9yK0FVSEJZajJ5NDdzRE5CZlE9PQ'`
     * @param string|null $additionalHashData Additional data that was included in hash calculation during encryption.
     *               * *Example:* `'2024-12-25T10:00:00Z'`
     * 
     * @return string Returns the decrypted string if the hash is valid.
     *                * *Example:* `'Hello World'`
     * 
     * @throws \RuntimeException If the Base64 URL encoded encrypted string is invalid.
     * @throws \LogicException If the hash is valid but decryption fails.
     */
    public function verifyHashAndDecrypt(string $encryptedString, ?string $additionalHashData = null): string
    {
        $components = explode("#", $this->decodeBase64URL($encryptedString));

        if (count($components) !== 2) {
            throw new \RuntimeException('Invalid format for the Base64 URL encoded string.');
        }

        $aesCbcEncryptedString = $components[0];
        $hash = $components[1];

        $hashInput = $aesCbcEncryptedString . ($additionalHashData ?? '');
        
        if ($this->hkdfEquals($hashInput, $hash)) {
            try {
                return $this->decryptAesCbcString($aesCbcEncryptedString);
            } catch (\RuntimeException $e) {
                throw new \LogicException('Hash is valid but decryption fails: ' . $e->getMessage());
            }
        }

        throw new \RuntimeException('Invalid hash for the Base64 URL encoded string.');
    }


    /**
     * Hashes a string using HKDF with SHA3-224 and returns a string in the format of `hash`@`salt`.
     *
     * @param string $string The string to hash.
     *               * *Example:* `'Hello World'`
     * 
     * @return string The hashed string with salt.
     * * *Example:* `'2VrazmQuSS0alphnIsMXGBp2LEzmiCpcxMJ/Mg==@0VJpOVEUTZqDG8J4DGlRqA=='`
     */
    public function hashHkdf(string $string): string
    {
        $salt = random_bytes(16);
        $hash = hash_hkdf('SHA3-224', $this->hkdfKey, 0, $string, $salt);

        // Return the Base64 encoded hash with the salt in the format of `hash`@`salt`.
        return base64_encode($hash) . '@' . base64_encode($salt);
    }

    /**
     * Compares a string with a HKDF hashed string with salt in the format of `hash`@`salt`.
     *
     * @param string $string The string to compare.
     *               * *Example:* `'Hello World'`
     * 
     * @param string $hashedString The HKDF hashed string with salt in the format of `hash`@`salt`.
     * * *Example:* `'2VrazmQuSS0alphnIsMXGBp2LEzmiCpcxMJ/Mg==@0VJpOVEUTZqDG8J4DGlRqA=='`
     * 
     * @return bool True if the strings are equal, false otherwise.
     * 
     * @throws \RuntimeException If the HKDF hashed string is invalid format.
     */
    public function hkdfEquals(string $string, string $hashedString): bool
    {
        $components = explode('@', $hashedString);

        if (count($components) !== 2) {
            throw new \RuntimeException('Invalid format for the HKDF hashed string.');
        }

        $hash = base64_decode($components[0]);
        $salt = base64_decode($components[1]);

        $reHash = hash_hkdf('SHA3-224', $this->hkdfKey, 0, $string, $salt);

        return hash_equals($hash, $reHash);
    }

    /**
     * Encrypts a string using the AES-256-CBC algorithm and returns the encrypted string in the format of `string`@`iv`.
     * 
     * @param string $targetString The string to encrypt.
     *               * *Example:* `'Hello World'`
     * 
     * @return string The encrypted string in the format of `string`@`iv`.
     * * *Example:* `'hexzX3nLJKqMWuXEhiOQHQ==@IsMEmTl11x6Siyyug2HBnw=='`
     * 
     * @throws \LogicException If the encryption fails.
     */
    public function encryptAesCbcString(string $targetString): string
    {
        $iv = random_bytes(16);

        $encryptedData = openssl_encrypt(
            $targetString,
            'AES-256-CBC',
            $this->opensslKey,
            OPENSSL_RAW_DATA,
            $iv
        );

        if ($encryptedData === false) {
            throw new \LogicException('Encryption failed.');
        }

        // Return the Base64-encoded encrypted string in the format `string`@`iv`.
        return base64_encode($encryptedData) . '@' . base64_encode($iv);
    }

    /**
     * Decrypts a string that was encoded using AES-256-CBC algorithm with the format of `string`@`iv`.
     * 
     * @param string $encryptedString The encrypted string to decrypt in the format of `string`@`iv`.
     *               * *Example:* `'hexzX3nLJKqMWuXEhiOQHQ==@IsMEmTl11x6Siyyug2HBnw=='`
     * 
     * @return string The decrypted string.
     * * *Example:* `'Hello World'`
     * 
     * @throws \RuntimeException If the decryption fails.
     */
    public function decryptAesCbcString(string $encryptedString): string
    {
        $components = explode('@', $encryptedString);
        if (count($components) !== 2) {
            throw new \RuntimeException('Invalid format for the encrypted string.');
        }

        $encryptedData = base64_decode($components[0]);
        $iv = base64_decode($components[1]);

        $decryptedData = openssl_decrypt(
            $encryptedData,
            'AES-256-CBC',
            $this->opensslKey,
            OPENSSL_RAW_DATA,
            $iv
        );

        if ($decryptedData === false) {
            throw new \RuntimeException('Decryption failed.');
        }

        return $decryptedData;
    }

    /**
     * Encodes a string to Base64 URL.
     *
     * @param string $string The string to encode.
     *               * *Example:* `'Hello World'`
     * 
     * @return string The Base64 URL encoded string.
     *                * *Example:* `'SGVsbG8gV29ybGQ'`
     */
    public function encodeBase64URL(string $string): string
    {
        $base64 = base64_encode($string);
        $urlSafe = strtr($base64, '+/', '-_');
        return rtrim($urlSafe, '=');
    }

    /**
     * Decodes a Base64 URL encoded string.
     *
     * @param string $encodedString The Base64 URL encoded string to decode.
     *               * *Example:* `'SGVsbG8gV29ybGQ'`
     * 
     * @return string The decoded string.
     *                * *Example:* `'Hello World'`
     */
    public function decodeBase64URL(string $encodedString): string
    {
        $str = strtr($encodedString, '-_', '+/');
        $padding = strlen($str) % 4;
        if ($padding !== 0) {
            $str = str_pad($str, strlen($str) + (4 - $padding), '=', STR_PAD_RIGHT);
        }
        return base64_decode($str);
    }
}